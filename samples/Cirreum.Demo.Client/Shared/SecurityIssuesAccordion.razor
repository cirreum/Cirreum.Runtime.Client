@* Security issues accordion component with filtering capabilities *@
@using Cirreum.Authorization.Analysis

<div class="security-issues-section p-1">
	@if (AnalysisReport.HasIssues == true) {
		// Use the enhanced extension method
		var summary = AnalysisReport.GetSummary();

		<!-- Summary Stats -->
		<div class="security-summary mb-3">
			<div class="d-flex gap-2 align-items-center">
				<span class="badge bg-danger">@summary.ErrorCount Errors</span>
				<span class="badge bg-warning">@summary.WarningCount Warnings</span>
				<span class="badge bg-info">@summary.InfoCount Info</span>
				<span class="text-muted ms-2">Total: @summary.TotalIssues issues found</span>
				@if (!summary.Passed) {
					<span class="badge bg-dark ms-auto">‚ùå FAILED</span>
				}
			</div>
		</div>

		<!-- Filter Buttons (NEW) -->
		<div class="filter-buttons mb-3">
			<button class="btn btn-sm @(FilterSeverity == null ? "btn-primary" : "btn-outline-primary")"
					@onclick="() => SetFilter(null)">
				All Issues
			</button>
			<button class="btn btn-sm @(FilterSeverity == IssueSeverity.Error ? "btn-danger" : "btn-outline-danger")"
					@onclick="() => SetFilter(IssueSeverity.Error)">
				Errors Only
			</button>
			<button class="btn btn-sm @(FilterSeverity == IssueSeverity.Warning ? "btn-warning" : "btn-outline-warning")"
					@onclick="() => SetFilter(IssueSeverity.Warning)">
				Warnings Only
			</button>
			<button class="btn btn-sm @(FilterSeverity == IssueSeverity.Info ? "btn-info" : "btn-outline-info")"
					@onclick="() => SetFilter(IssueSeverity.Info)">
				Info Only
			</button>
		</div>

		<!-- Security Issues Accordion -->
		<Accordion ExpandMode="AccordionExpandMode.Single">
			@{
				// Use enhanced grouping methods
				var issuesBySeverity = FilterSeverity.HasValue 
					? AnalysisReport.FilterBySeverity(FilterSeverity.Value).GetIssuesBySeverity()
					: AnalysisReport.GetIssuesBySeverity();
			}
			
			@foreach (var (severity, severityIssues) in issuesBySeverity.OrderByDescending(kvp => kvp.Key)) {
				@foreach (var categoryGroup in severityIssues.GroupBy(i => i.Category).OrderBy(g => g.Key)) {
					@foreach (var issue in categoryGroup.Select((issue, index) => new { issue, index })) {
						<AccordionItem>
							<HeaderTemplate>
								<div class="d-flex align-items-center gap-2 overflow-hidden lh-base w-100">
									<!-- Severity Icon -->
									<i class="@GetSeverityIcon(issue.issue.Severity) @GetSeverityColorClass(issue.issue.Severity)"
									   aria-hidden="true"></i>

									<!-- Severity Badge -->
									<span class="badge @GetSeverityBadgeClass(issue.issue.Severity)">
										@issue.issue.Severity
									</span>

									<!-- Category Badge -->
									<span class="badge bg-secondary">@issue.issue.Category</span>

									<!-- Issue Description -->
									<span class="flex-fill text-truncate me-2">@issue.issue.Description</span>

									<!-- Related Objects Count -->
									@if (issue.issue.RelatedTypeNames.Count > 0) {
										<small class="me-2 text-muted text-nowrap">
											@issue.issue.RelatedTypeNames.Count type(s)
										</small>
									}
								</div>
							</HeaderTemplate>
							<ChildContent>
								<div class="issue-details">
									<!-- Full Description -->
									<div class="mb-3">
										<h6 class="text-primary">Description</h6>
										<p class="mb-0">@issue.issue.Description</p>
									</div>

									<!-- Category Info -->
									<div class="mb-3">
										<h6 class="text-primary">Category</h6>
										<span class="badge bg-light text-dark">@issue.issue.Category</span>
									</div>

									<!-- Related Types (FIXED) -->
									@if (issue.issue.RelatedTypeNames.Count > 0) {
										<div class="mb-3">
											<h6 class="text-primary">Related Types</h6>
											<div class="related-objects">
												@foreach (var typeName in issue.issue.RelatedTypeNames) {
													<div class="related-object-item">
														<code class="p-1 rounded">@typeName</code>
													</div>
												}
											</div>
										</div>
									}

									<!-- Recommendations -->
									@if (!string.IsNullOrEmpty(GetRecommendation(issue.issue))) {
										<div class="mb-3">
											<h6 class="text-success">üí° Recommendation</h6>
											<div class="alert alert-light border-start border-success border-3 mb-0">
												@GetRecommendation(issue.issue)
											</div>
										</div>
									}

									<!-- Additional Context (NEW) -->
									<div class="additional-info text-muted small">
										<span>Analyzer: @issue.issue.Category</span>
										@if (issue.issue.RelatedTypeNames.Count > 0) {
											<span class="ms-3">Affects @issue.issue.RelatedTypeNames.Count type(s)</span>
										}
									</div>
								</div>
							</ChildContent>
						</AccordionItem>
					}
				}
			}
		</Accordion>
	} else {
		<!-- No Issues Found -->
		<div class="alert alert-success d-flex align-items-center">
			<i class="bi bi-check-circle-fill me-2 fs-4" aria-hidden="true"></i>
			<div>
				<h5 class="alert-heading mb-1">No Security Issues Found! üéâ</h5>
				<p class="mb-0">Your authorization system appears to be properly configured with no detected security concerns.</p>
			</div>
		</div>
	}
</div>

<style>
	.security-summary .badge {
		font-size: 0.9em;
	}

	.filter-buttons .btn {
		font-size: 0.875rem;
	}

	.related-objects {
		display: flex;
		flex-direction: column;
		gap: 8px;
	}

	.related-object-item {
		display: flex;
		align-items: center;
		flex-wrap: wrap;
	}
	
	.related-object-item code {
		background: var(--bs-tertiary-bg);
		font-family: var(--bs-font-monospace);
		font-size: 0.875em;
	}

	.issue-details h6 {
		font-size: 0.9rem;
		font-weight: 600;
		margin-bottom: 0.5rem;
	}

	.additional-info {
		padding-top: 1rem;
		border-top: 1px solid var(--bs-border-color);
		margin-top: 1rem;
	}
</style>

@code {

	[Parameter, EditorRequired] public required AnalysisReport AnalysisReport { get; set; }
	
	private IssueSeverity? FilterSeverity { get; set; }

	private void SetFilter(IssueSeverity? severity) {
		FilterSeverity = severity;
		StateHasChanged();
	}

	private string GetSeverityIcon(IssueSeverity severity) => severity switch {
		IssueSeverity.Error => "bi bi-exclamation-triangle-fill",
		IssueSeverity.Warning => "bi bi-exclamation-triangle",
		IssueSeverity.Info => "bi bi-info-circle",
		_ => "bi bi-question-circle"
	};

	private string GetSeverityColorClass(IssueSeverity severity) => severity switch {
		IssueSeverity.Error => "text-danger",
		IssueSeverity.Warning => "text-warning", 
		IssueSeverity.Info => "text-info",
		_ => "text-secondary"
	};

	private string GetSeverityBadgeClass(IssueSeverity severity) => severity switch {
		IssueSeverity.Error => "bg-danger",
		IssueSeverity.Warning => "bg-warning text-dark",
		IssueSeverity.Info => "bg-info",
		_ => "bg-secondary"
	};

	private string GetRecommendation(AnalysisIssue issue) {
		// Expanded recommendations
		return issue.Category switch {
			"Role Hierarchy" when issue.Description.Contains("circular") =>
				"Review your role inheritance configuration to remove circular dependencies. Consider simplifying the role hierarchy.",

			"Role Hierarchy" when issue.Description.Contains("isolated") =>
				"Connect isolated roles to the main hierarchy or remove them if they're no longer needed.",
				
			"Role Hierarchy" when issue.Description.Contains("depth") =>
				"Consider flattening the role hierarchy to reduce complexity and improve performance.",

			"Authorization Rules" when issue.Description.Contains("no authorization") =>
				"Add appropriate authorization validators or policy validators to protect these resources.",
				
			"Enhanced Authorization Rules" when issue.Description.Contains("no authorization protection") =>
				"Critical: These resources have no protection. Add validators immediately or consider if they should be public.",

			"Policy Validators" when issue.Description.Contains("same order") =>
				"Assign unique order values to policy validators to ensure predictable execution sequence.",

			"Policy Validators" when issue.Description.Contains("no resources use this attribute") =>
				"Either remove the unused policy validator or apply the target attribute to relevant resources.",
				
			"Policy Validators" when issue.Description.Contains("runtime") =>
				"Ensure policy validators specify the correct runtime types they support.",

			// Domain Architecture recommendations
			"Domain Architecture" when issue.Description.Contains("anonymous request types with no authorization") =>
				"Review these anonymous operations to ensure they should be public. Add authorization validators for any that contain sensitive data or operations.",
			
			"Domain Architecture" when issue.Description.Contains("that might need authorization") =>
				"These anonymous operations have names suggesting they might need protection (e.g., Delete, Admin, Update). Carefully review each one and add appropriate authorization.",
			
			"Domain Architecture" when issue.Description.Contains("low coverage") =>
				"These domains have significant numbers of unprotected operations. Consider a systematic review to ensure appropriate authorization coverage.",
			
			"Domain Architecture" when issue.Description.Contains("more anonymous than protected") =>
				"Domains with mostly anonymous operations may indicate missing authorization. Review the architecture to ensure security boundaries are properly defined.",
			
			"Domain Architecture" when issue.Description.Contains("Excellent! All domain operations") =>
				"Great work! Continue periodic reviews of anonymous operations as the system evolves to maintain security.",
			
			"Domain Architecture" when issue.Description.Contains("Good authorization coverage") =>
				"You have strong coverage. Focus reviews on the remaining anonymous operations to ensure they are intentionally public.",
			
			"Domain Architecture" when issue.Description.Contains("'Other' domain") =>
				"Organize these operations into proper business domain namespaces (e.g., Domain.Customers.Commands) for better architecture clarity and maintainability.",
			
			"Domain Architecture" when issue.Description.Contains("derived interfaces") =>
				"Ensure your authorization validators properly handle interface inheritance (e.g., IDomainCommand, IAuthorizableRequest) to maintain security.",

			_ => string.Empty
		};
	}
}